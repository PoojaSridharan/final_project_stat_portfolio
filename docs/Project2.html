<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>PORTFOLIO - Final Project</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">PORTFOLIO</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./contact.html"> 
<span class="menu-text">Contact</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Projects.html"> 
<span class="menu-text">Projects</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./SourceCode.html"> 
<span class="menu-text">Source Code</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#reference" id="toc-reference" class="nav-link active" data-scroll-target="#reference">Reference:</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Final Project</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><strong>Abstract</strong>&nbsp;</p>
<p>As people, it is important to understand the different resources we have access to in order to better inform ourselves if we come across any issues that relate to health-related problems. Specifically, being knowledgeable on different insurance types is important because it helps you understand which hospital takes what insurance as well as which one is more affordable based on health needs. Different insurance types have different benefits that can help cover the cost of different treatments, medications, and other services that can help promote and mitigate issues. Specifically, insurance helps minimize the amount a patient has to pay out of pocket and gives patients a sense of ease that it is covered. As mentioned before, with access to insurance, it allows patients to have access to doctors that can help with diagnosing any conditions while providing a path forward. With accessibility to insurance, it also encourages a healthier lifestyle as it does not provide any monetary limitations to patients.&nbsp;</p>
<p><strong>Introduction</strong>&nbsp;</p>
<p>As mentioned before there are many different benefits to learning about Health Care and Insurance as it promotes the overall well-being of individuals. To best support our research questions, we have decided to use different statistical models to answer our research questions below:&nbsp;</p>
<p><strong>Research Questions</strong>&nbsp;</p>
<ol type="1">
<li>How does patient information like length of stay, age, gender, medical conditions and admission type impact medical billing amounts?&nbsp;&nbsp;&nbsp;</li>
</ol>
<!-- -->
<ol start="2" type="1">
<li>How hospital stays (length of stay and medical condition) in different hospitals influence billing amounts for patients?&nbsp;</li>
</ol>
<!-- -->
<ol start="3" type="1">
<li>How are blood types related to certain medical conditions?&nbsp;</li>
</ol>
<p>Our goal is to understand the influence of length of stay, age, gender, medical conditions and admission type on the billing amount. In addition, we want to understand how different hospitals influence billing amounts, for patients with similar medical conditions and stay lengths and identify whether hospitals with similar services charge differently. Lastly, for our last research question, it’s important to be aware of which blood type is more common with certain blood types.&nbsp;</p>
<p><strong>Dataset</strong>&nbsp;</p>
<p>The Healthcare Dataset highlights information relating to patient information and insurance information of patients. For example, it lists the age, gender, medical condition, blood type, and other factors of different patients. Variables that affect insurance include the type of insurance, billing amount, hospital, length of stay, discharge date, and type of admission. All of the variables are important to consider as it affects pricing, and it gives you the opportunity to explore different types of variables and the relationships between them. Lastly, it gives an insight into how hospitals take different insurance providers and the pricing of it.&nbsp;</p>
<p><strong>Research Questions Analysis and Interpretations</strong>&nbsp;</p>
<p><strong>Patient Information Affecting Billing Amount</strong>&nbsp;</p>
<p>To start we will dive deeper into understanding how different variables of patient information affect the billing amount. We will use LASSO Regression Model to identify and quantify the impact of patient information like age, gender, medical conditions, length of stay, and admission type on medical billing amounts. This method helps to select the most influential variables and reduce overfitting through regularization.&nbsp;</p>
<p>To answer our first research question, the packages that need to be installed are the dplyr, caret, and glmnet packages. This will be used to execute a LASSO Regression Model. When executing code in R-Studio Cloud, the dplyr package will be commonly used since it is used for data manipulation. Specifically, there are distinct functions that make it easier to analyze and interpret data and it is part of the tidyverse package. The caret package helps with evaluating and training machine learning models. Some distinctive features that can be executed with this package include data splitting, pre-processing, model training, hyperparameter tuning, model evaluation, cross validation, and lastly model comparison. The glmnet package is used for fitting different regression models like LASSO and Ridge Regression. In addition, it also allows you to the the elastic net function, regularization path, and fitting generliazed linear models.&nbsp;&nbsp;</p>
<p><strong>Process</strong>&nbsp;</p>
<p>To dive deeper, we will go over the process of how we used LASSO Regression to answer our research question. After importing the packages mentioned above, we will remove the following variables “Date_of_Admission”, “Discharge_Date”, “Hospital”, “Insurance_Provider”, and “Name”. These variables were removed because they are insignificant to this dataset and this new dataset will be stored into a new variable. We will take the significnat variables and from there convert the categorical variables into factor variables since R-Studio does not know that it is classified as categorical data. After converting the variables to factor variables, we will create a matrix that will convert the categorical variables into a numerical matrix format.&nbsp;&nbsp;</p>
<p>After the conversion of variables, the next step is to create dummy variables and transform the data to dummy variables. From there, we will combine these dummy variables with the Billing_Amount. Using the dummy variables that have been combined with Billing_Amount we will split the data into predictors (x) and the response variable (y) which is the Billing_Amount.&nbsp;&nbsp;</p>
<p>We will fit a LASSO Regression model using this information and calculate the best lambda value then extract those coefficients. We will take the best lambda value, fit the final LASSO Model, and display the coefficients. These coefficients show the important columns that will be used in the prediction model. The non-zero coefficients will also be extracted and displayed. Using the final LASSO Regression Model we constructed using the best lambda value, we will predict the values and calculate the residuals. Lastly, we will calculate the Mean Squared Error (MSE), Total Sum of Squares (TSS), Residual Sum of Squares (RSS), and R-Squared value.&nbsp;</p>
<p><strong>Interpretations</strong>&nbsp;</p>
<p><strong>Showing All Lambda Values</strong>&nbsp;</p>
<p><img src="final_project/1.jpeg" class="img-fluid"></p>
<p>Above the lambda values are shown. For higher lambda values, the coefficients of less important variables towards zero meaning it’s a simpler model with fewer predictors. It also applies a strong penalty which means there are more coefficients shrinking to zero and the data may be underfit if important predictors are removed. Lower lambda values mean that allows more predictors to have more non-zero coefficients making the model more complex. This means a weak penalty is applied, meaning there are more predictors remaining in the model, making it more complex. This can overfit the data if it becomes too flexible.&nbsp;</p>
<p><strong>Fitting LASSO Regression Model</strong>&nbsp;</p>
<p><img src="final_project/2.jpeg" class="img-fluid"></p>
<p>Lambda min is defined as the value of lambda that minimizes the cross validated Mean-Squared Error. The Lambda LSE is larger than the lambda value meaning that it is a simpler model with fewer non-zero coefficients with a standard error of minimum Mean-Squared Error (MSE). Lambda minimum and Lambda LSE are equal to 410 which means that the penalty strength minimizes the Mean Squared Error (MSE). This also makes the model scattered with only one non-zero predictor, and there were no other predictors considered as they have no impact on billing amount.&nbsp;</p>
<p><strong>Non-Zero Coefficients</strong>&nbsp;</p>
<p><img src="final_project/3.jpeg" class="img-fluid"></p>
<p>Above we are extracting non-zero coefficients from the LASSO Regression Model. This often produces models that are very scattered where many coefficients are shrunk to zero with very minimal predictors that are relevant. The intercept is 743.8284575 which represents the baseline prediction when all predictors are zero. The billing amount coefficient is 0.97 meaning that as billing amount increases, the predicted response will increase by 0.97. This shows that with an optimal lambda value the billing amount is a significant predictor while other variables are not included.&nbsp;&nbsp;</p>
<p><strong>Summary Statistics</strong>&nbsp;</p>
<p><img src="final_project/4.jpeg" class="img-fluid"></p>
<p>The Mean Squared Error (MSE) measures the average squared difference between actual and predicted billing amounts. The lower the value, the better the model’s performance. In this scenario it is equal to 168,140 which means that squared error between predicted and actual billing amounts is significant, but it depends on your data.&nbsp;&nbsp;</p>
<p>The Total Sum of Squares (TSS) shows the total variation of actual billing amounts meaning how spread out the values are from the mean. The value is 1.978 trillion and meaning there is high variability in billing amount across all patients. The larger the value, there is more variability in this dataset.&nbsp;</p>
<p>The Residual Sum of Squares (RSS) encapsulates the variation in actual billing amounts that is not explained by the model. The value is 1.681 billion which means that the amount of error in the model is failed to be explained. Normally a smaller Residual Sum of Squares (RSS) compared to Total Sum of Squares is better for a model.&nbsp;</p>
<p>The R-Squared value measures the variance in the actual billing amounts explained by the model. The value is 0.9992, which means that there is a 99.92% variance in billing amounds that is explained by the model. Overall, this means that this is an exceptionally good model fit but on the contrary a high R-Squared value can indicate overfitting which can be caused by many predictors or that the model is tested on training data instead of unseen data.&nbsp;</p>
<p><strong>LASSO Coefficient</strong>&nbsp;</p>
<p><img src="final_project/5.jpeg" class="img-fluid"></p>
<p>Based on the visualization above, the lower lambda values located on the left of the graph there are more predictors in the model making the bias lower and higher variance which can lead to overfitting. As the lambda increases, predictors become excluded making the model simpler, but this can lead to a higher Mean-Squared Error value. Lastly, an optimal lambda is used to help balance the simplicity of a model and prediction accuracy as you can see with the dotted vertical line.&nbsp;</p>
<p><strong>Conclusion</strong>&nbsp;</p>
<p>Based on the LASSO Model above and the following interpretations, we can conclude that patient information is not affected by the billing amount. The remaining variables other than the intercept have shrunk to zero meaning that they there are not significant to the model at the lambda.min value. The intercept represents the value for the response variable when all predictors are set at zero. Specifically for the billing amount, for any unit increase, the response variables increase by 0.97 while all other variables are constant. After completing a LASSO Regression Model for this question, we can see that there is no correlation between patient information and billing amount.&nbsp;</p>
<p><strong>Influence of Hospital Stay (Length of Stay and Medical Conditions) On Billing Amount</strong>&nbsp;</p>
<p>The purpose of this research question is to understand the influence of hospital stay based on length of stay and medical conditions and how it affects billing amount. We also want to see if hospitals with similar services charge different rates. To answer this research question, we will be using the LASSO Regression Model to handle multiple predictors and shrink irrelevant coefficients to zero, improving interpretability and generalization. The focus is tp group hospitals by average billing categories and examine how medical conditions and length of stay impact billing amount.&nbsp;</p>
<p><strong>Process</strong>&nbsp;</p>
<p>To understand how hospital stays (length of stay and medical conditions) in hospital affect billing amounts, we started by preparing the data. Based on their average billing amounts, we group hospitals into four categories - low, medium, high, and extremely high). This grouping simplifies comparisons between hospitals with similar services. Also, it helps to categorize hospitals as there are many. Since LASSO Regression only works with numeric data, we converted categorical variables like medical conditions and hospital billing groups into dummy variables. From there we combined all numeric variables, such as length of stay and these dummy variables, into a predictor matrix (X) and used the billing amount as the response variable (y). Using cross-validation, we identified the optimal penalty term that minimizes prediction error while shrinking irrelevant predictors to zero. This approach allows us to focus on the most significant factors driving billing amounts and ensures that the model generalizes well to new data.&nbsp;</p>
<p>The analysis utilized the glmnet, dplyr, and base R libraries to prepare the data, fit the LASSO Regression model, and interpret the results. The glmnet package was central to modeling and fitting LASSO Regression, performing cross-validation to identify the optimal penalty term, and extracting significant coefficients, which streamlined feature selection and regularization. The dplyr library was employed for data manipulation, including selecting relevant columns, grouping hospitals based on average billing, and merging datasets. Base R functions, such as model.matrix, apply, and cbind, were used to convert categorical variables into numeric dummy variables and to combine predictors into a matrix suitable for regression. Together, these libraries enabled efficient data preprocessing, model building, and result interpretation, addressing the research question comprehensively.&nbsp;</p>
<p><strong>Interpretations</strong>&nbsp;</p>
<p><strong>Lambda Values</strong>&nbsp;</p>
<p><img src="final_project/6.jpeg" class="img-fluid"></p>
<p><img src="final_project/7.jpeg" class="img-fluid"></p>
<p>The range of lambda values, from 9616.85 to 52.53, shows how the model balances complexity and simplicity. Smaller lambda values keep more predictors in the model, allowing for more detailed analysis, while larger values simplify the model by shrinking less important predictors to zero. The optimal lambda of 52.53 was chosen because it resulted in the lowest Mean Squared Error (MSE) of approximately 39,908,579. This means the model is accurate and streamlined, focusing on the most important predictors without overfitting the data.&nbsp;</p>
<p><strong>Coefficients of the Model</strong>&nbsp;</p>
<p><img src="final_project/8.jpeg" class="img-fluid"></p>
<p>The coefficients from the final model provide valuable insights into the factors influencing billing amounts. The length of stay significantly impacts billing, with each additional day adding approximately 30,796.85 to the total charges. Among medical conditions, Arthritis has a minor negative effect (-121.07), while Diabetes shows a very slight positive influence (0.30), and other medical conditions were not statistically significant.&nbsp;</p>
<p><strong>Non-Zero Coefficients</strong>&nbsp;</p>
<p><img src="final_project/9.jpeg" class="img-fluid"></p>
<p><strong>Non-Zero Coefficients</strong>&nbsp;<strong>Billing Group</strong>&nbsp;</p>
<p><img src="final_project/10.jpeg" class="img-fluid"></p>
<p>Hospital billing groups play a major role: hospitals in the “Low” billing group charge significantly less (-22,821.19), “Medium” billing group hospitals charge moderately less (-10,605.12), and hospitals in the “Very High” group charge significantly more (12,464.31). These findings suggest that while medical conditions have limited influence, the length of stay and hospital pricing tiers are the most important factors driving billing amounts.&nbsp;</p>
<p><strong>MSE</strong>&nbsp;</p>
<p><img src="final_project/11.jpeg" class="img-fluid"></p>
<p><strong>R-Squared</strong>&nbsp;</p>
<p><img src="final_project/12.jpeg" class="img-fluid"></p>
<p>The Mean-Squared Error (MSE) of approximately 39,862,744 represents the average squared difference between the observed and predicted billing amounts. This metric indicates the model’s overall error, with smaller values signifying better accuracy. The R-Squared value of 0.7985 suggests that the model explains about 79.85% of the variability in hospital billing amounts, demonstrating a strong fit for the data. This indicates that the predictors, such as length of stay, billing group, and certain medical conditions, effectively capture the key drivers of billing variation.&nbsp;</p>
<p><strong>LASSO Coefficients</strong>&nbsp;</p>
<p><img src="final_project/13.jpeg" class="img-fluid"></p>
<p>The Coefficient Path Plot visualizes how the Lasso regression model behaves as the penalty parameter λ\lambda changes. The X-axis (Log(λ)) represents the logarithmic scale of the penalty values, with larger values imposing stronger regularization, forcing less significant predictors toward zero. The Y-axis (MSE) shows the Mean Squared Error for each λ\lambda, with the red dots indicating the model’s error at different penalty levels. The left dashed line marks λmin\lambda_{min}, the value of λ\lambda where the MSE is minimized, meaning the model achieves the best balance between predictive accuracy and simplicity. The plot demonstrates that as λ\lambda increases, the less important predictors are gradually excluded from the model, leaving only the most influential ones at λmin\lambda_{min}. This ensures the model focuses on the variables that significantly impact billing while reducing overfitting and improving generalizability.&nbsp;</p>
<p><strong>Conclusion</strong>&nbsp;</p>
<p>The analysis reveals that length of stay is a strong predictor of hospital billing amounts, with longer stays resulting in significantly higher costs. Among medical conditions, only a few, such as Arthritis and Diabetes, showed minor influence, indicating that billing is less sensitive to specific conditions. In contrast, hospital billing groups had a substantial impact, highlighting notable disparities in pricing across hospitals, with “Low” and “Medium” groups reducing costs and “Very High” groups increasing them. Overall, the study successfully addresses the research question by identifying the primary predictors of hospital billing and quantifying their effects, offering valuable insights into the factors driving cost variations.&nbsp;</p>
<p><strong>Blood Types Related to Certain Medical Conditions</strong>&nbsp;</p>
<p>Our last research question is understanding if blood types are related to certain medical conditions. We will use the Chi-Squared test to answer this question. The libraries that will be used for this scenario are the glmnet and dplyr packages. Glmnet is used for regression modeling and dplyris used for data manipulation. We will load the dataset using the read.xlsx file.&nbsp;</p>
<p>After importing these packages and loading the dataset, we will create a contigency table. The purpose of contingency table is to summarize the different frequencies of blood type and medical condition. Using this information we will perform the Chi-Squared test to see if there is a relationship between blood type and medical condition. The results that we will expect have the Chi-Squared statistic, p-value, and degrees of freedom. The Chi-Squared statistic indicates how the observed data deviates from the expected data under the null hypothesis. The p-value shows if the relationship is significant and lastly, the degrees of freedom show the different independent comparisons in the test.&nbsp;</p>
<p><strong>Interpretations</strong>&nbsp;</p>
<p>Null Hypothesis&nbsp;</p>
<p>The null hypothesis for the Chi-Square test states that the two categorical variables, Blood_Type and Medical_Condition, are independent.&nbsp;</p>
<p>P-Value&nbsp;</p>
<p>The p-value of 0.8784 is much greater than the common significance level of 0.05 which indicates that there is no evidence to reject the null hypothesis.&nbsp;</p>
<p><strong>Conclusion</strong>&nbsp;</p>
<p>Based on the high p-value, we fail to reject the null hypothesis. This suggests that there is no statistically significant association between Blood_Type and Medical_Condition in the given dataset.&nbsp;</p>
<p><strong>Advantages of LASSO Regression</strong>&nbsp;</p>
<ul>
<li>Feature Selection - shrinks coefficients to exactly zero making it a more interpretable model&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Reduces Overfitting - prevents overfitting since it is penalizing large coefficients &nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Handles Multicollinearity - Multicollinearity is a high correlation between predictors and LASSO can handle it as it will only select one significant variable and shrink the others to zero&nbsp;</li>
</ul>
<p><strong>Disadvantages of LASSO Regression</strong>&nbsp;</p>
<ul>
<li>Bias in Estimates - since variables that have high coefficients shrink to zero it can introduce bias&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Exclusion of Relevant Variables - eliminating all coefficients that are not significant may not always be useful since it seems as if there is a weak association between the target variable it will be shrunk to zero&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Cannot Handle Non-Linear Relationships - It is assumed that the predictors and response variables have a linear relationship making it harder to interpret the non-linear relationships&nbsp;</li>
</ul>
<p><strong>Advantages of Chi-Squared Test</strong>&nbsp;</p>
<ul>
<li>Simple and Easy to Use - very straightforward and easy to compute specifically for small and medium datasets&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Handles Large Sample Sizes - Provides reliable results with large sample sizes&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Insightful for Categorical Data - Chi-Squared tests are good and useful when exploring relationships between categorical variables in contingency tables&nbsp;</li>
</ul>
<p><strong>Disadvantages of Chi-Squared Test</strong>&nbsp;</p>
<ul>
<li>Sensitive to Sample Size - For large samples, even small differences appear significant. For small samples, it might have the capability to detect significant relationships&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Cannot Handle Small Expected Frequencies - For this test to be complete there needs to be enough observations for each category meaning if there is a contingency table with low frequencies it can lead to unreliable results&nbsp;</li>
</ul>
<!-- -->
<ul>
<li>Overlooks Non-Linear Relationships - Chi-Squared test is not designed to interpret non-linear relationships or complex factors between variables&nbsp;</li>
</ul>
<section id="reference" class="level2">
<h2 class="anchored" data-anchor-id="reference">Reference:</h2>
<p><br>
[1] “data.world,” [Online]. Available: <a href="https://data.world/ninami/healthcare-dataset" class="uri">https://data.world/ninami/healthcare-dataset</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>